<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Szczegóły Projektów</title>
    <link rel="stylesheet" href="styles.css">
    <!-- PrismJS Syntax Highlighting (Blue theme) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-coy.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="prism.css">
</head>
<body>
<header>
    <h1>Fragmenty kodu</h1>
    <button id="menu-toggle" class="hamburger" aria-label="Menu">
        &#9776;
    </button>
    <nav>
        <ul>
            <li><a href="index.html">Strona Główna</a></li>
            <li><a href="projects.html">Projekty</a></li>
            <li><a href="project-details.html">Fragmenty kodu</a></li>
            <li><a href="interests.html">Zainteresowania</a></li>
            <li><a href="photos.html">Zdjęcia</a></li>
        </ul>
    </nav>
</header>

<main>
    <section>
        <h3>
            <p>- Jakimi fragmentami kodu chciałbym się pochwalić?</p>
            <p>- W projektach, które opisałem w zakładce "Projekty", kod pisany był bardzo prosto, bez żadnych sztuczek implementacyjnych.
                Z tego względu zamieszczam kilka problemów, krótki opis algorytmu i (ciekawą) część implementacji w C++.</p>
        </h3>
    </section>

    <section id="project1">
        <h2>Sumy częściowe</h2>
        <img src="sumy_częściowe.png" alt="sumy częściowe" class="problem">
        <p>Każdy wyraz ciągu b można policzyć osobno, sumując kolejne wyrazy ciągu a. To podejście ma jednak złożoność kwadratową. Stosuję lepszą metodę, sumuję wszystkie wyrazy ciągu a i w ten sposób otrzymuję b(1). Zauważam, że b(i) = b(i-1) - a(i), dla i = 2,3,...,n i wyliczam wszystkie pozostałe b(i).</p>
        <pre><code class="language-cpp">int n,t[1000001];
long long res;
int main()
{
    std::ios_base::sync_with_stdio(0);
    cin>>n;
    for(int i=1; i<=n; i++){
        cin>>t[i];
        res+=t[i];
    }
    for(int i=1; i<=n; i++){
        res-=t[i-1];
        cout << res << " ";
    }

    return 0;
}
</code></pre>
    </section>

    <section id="project2">
        <h2>Cięcie prostokątów</h2>
        <img src="recantgle_cutting.png" alt="recantgle_cutting" class="problem">
        <p>Wynik dla prostokąta o wymiarach (a,b) będzie równy sumie wyników najkorzystniejszego z podziałów tego prostokąta + 1. Można by się wywoływać rekurencyjnie i liczyć to samo dla mniejszych prostokątów aż natrafi się na kwadraty. Jednakże, wywołując rekurencyjnie, często liczy się wielokrotnie wynik dla tych samych wymiarów prostokątów. Z tego względu wykorzystam programowanie dynamiczne, co zaoszczędzi mi wielu operacji.</p>
        <pre><code class="language-cpp">#include &lt;bits/stdc++.h>;

using namespace std;
int dp[501][501],a,b;
int main()
{
    cin>>a>>b;

    for(int i=1; i&lt;=a; i++){
        for(int j=1; j&lt;=b; j++){
            dp[i][j]=INT_MAX;
            if(i==j){
                dp[i][j]=0;
            }
            else{
                for(int k=1; k&lt;i; k++){
                    dp[i][j]=min(dp[i][j], dp[k][j]+dp[i-k][j]+1);
                }
                for(int k=1; k&lt;j; k++){
                    dp[i][j]=min(dp[i][j], dp[i][k]+dp[i][j-k]+1);
                }
            }
        }
    }
    cout&lt;&lt;dp[a][b];

    return 0;
}
</code></pre>
    </section>

    <section id="project3">
        <h2>Dijkstra</h2>
        <p>Na koniec wrzucam moją implementację algorytmu dijkstry, czyli rozwiązania problemu znajdowania najkrótszej ścieżki w grafie (w tym przypadku skierowanym).</p>
        <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
ll n,m,x=1e18;
vector&lt;ll&gt; dis;
bool vis[1000001],k[1000001];
priority_queue&lt;pair&lt;ll,ll&gt;&gt; q;
vector&lt;pair&lt;ll,ll&gt;&gt; adj[1000001];

int main()
{
    cin>>n>>m;
    for(int i=1; i&lt;=m; i++){
        ll a,b,c;
        cin>>a>>b>>c;
        adj[a].push_back({b,c});
    }
    dis.resize(n+2,x);
    dis[1]=0;
    q.push({0,1});
    while(!q.empty()){
        ll v=q.top().second;
        q.pop();
        if(!vis[v]){
            vis[v]=true;
            for(auto it: adj[v]){
                if(dis[v]+it.second&lt;dis[it.first]){
                    dis[it.first]=dis[v]+it.second;
                    q.push({-dis[it.first],it.first});
                }
            }
        }
    }
    for(int i=1; i&lt;=n; i++){
        cout&lt;&lt;dis[i]<<" ";
    }
    return 0;
}
</code></pre>
        </section>
</main>

<footer>
    <p>&copy; 2025 Moje Portfolio</p>
</footer>

<!-- PrismJS -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-coy.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
<script>Prism.highlightAll();</script>

<script src="prism.js"></script>
<script src="script.js"></script>
</body>
</html>
